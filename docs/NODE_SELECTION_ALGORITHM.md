# Алгоритм выбора нод под задание

Последнее обновление: 2026-02-07

## 1. Что есть в базе (реальные ноды)

- **GSE_VOCAB** (~39k): `descriptor` = одно слово (например "personification", "reasonableness"). `sourceKey` — хеш. Подходят для «используй слова: A, B, C».
- **GSE_GRAMMAR** (~456): `descriptor` = длинное «Can …» (например "Can use 'since …' to talk about reasons, causes and explanations"). `sourceKey` = id, по нему эвалюатор матчит grammar check → нода. Evidence по грамматике создаётся **только** если в ответе эвалюатора есть `grammarChecks[].descriptorId === node.sourceKey`.
- **GSE_LO** (~1.4k): `descriptor` = длинное «Can …» (speaking/writing). Evidence по overlap с `loChecks` из эвалюатора.

Типы нод используются:
- в **генераторе**: по `targetNodeTypes` разделяют на «слова для ученика» (VOCAB) и «learning objectives» для промпта (GRAMMAR/LO);
- в **evidence**: VOCAB — появление слова/фразы; GRAMMAR — матч по sourceKey с чеком; LO — матч по overlap с loChecks.

---

## 2. Ограничения по типам

- **Три грамматических ноды в одном задании** — в промпте три длинных «Can…»; ученик в одном ответе скорее затронет 1–2 конструкции. Часть нод может не получить evidence. Разумнее не набирать 3 чисто grammar в одну тройку.
- **Три LO** — то же: много целей в одном задании размывает фокус и проверку.
- **Vocab** — несколько слов в одном задании нормально (генератор даёт список слов, evidence по каждому слову отдельно).
- **read_aloud**: для вокаба даёт только supporting/low impact; для верификации read_aloud не использовать (правило из обсуждения).

Итого по составу тройки: учитывать типы не «сначала домен, потом три ноды из него», а **ограничение на смесь**: например не более одной grammar и не более одной LO в одной тройке, остальное — vocab; или «хотя бы один vocab» и «не более двух non-vocab». Так задание остаётся с одним–двумя явными целями (grammar/LO), остальное — слова.

---

## 3. Полный алгоритм выбора нод (актуальный)

**Входы:** stage, target_stage, prev_stage; ноды в диапазоне [prev_stage, target_stage] с value, sigma, lastEvidenceAt, status, domain (type), inBundle; очередь верификации; при цели «Тренировка» — ноды уровня ниже с понижающим коэффициентом.

### Шаг 1. Цель
- **Верификация** — очередь верификации не пуста.
- **Тренировка** — иначе.

### Шаг 2. Пул
- **Верификация:** пул = очередь верификации.
- **Тренировка:** пул = все ноды с value < 70 в диапазоне [prev_stage, target_stage] (включая уровень ниже). Очередь верификации в пул не входит.

### Шаг 3. Веса и лотерея
- **Верификация:** веса по давности и слабости; лотерея без возвращения → **2 ноды** (или 1, если в очереди одна).
- **Тренировка:**  
  - вес = (70 − value)_clip × recency_mult × (1.5 если inBundle) × **(0.6–0.7 если нода с prev_stage)**.  
  - Лотерея без возвращения → **3 ноды**.

### Шаг 4. Ограничение по типам (тренировка)
После выбора 3 нод проверить состав по типам:
- Не более **1 grammar** и не более **1 LO** в тройке (или эквивалентное правило: не более 2 non-vocab).
- Если нарушено — заменить «лишние» ноды на следующих по весу из пула (vocab или другую grammar/LO), пока состав не выполнен.

### Шаг 5. Верификация — тип задания
При цели «Верификация» тип задания ≠ read_aloud.

---

## 4. Что не делать
- Не выбирать «топ-2/3 по сортировке» без лотереи — залипание на одних нодах.
- Не делать отдельную цель «Освежить» при пустом пуле прогресса — один пул «Тренировка» с приоритетом бандла в весах.
- Не смешивать в одном пуле верификацию и тренировку: либо пул = очередь верификации, либо пул = тренировочные ноды.
- Не игнорировать уровень ниже: ноды prev_stage в пуле с понижающим коэффициентом.

---

## 5. Скрипт для просмотра нод
`npx tsx src/scripts/inspect_gse_nodes.ts` — выборка по типам (descriptor, sourceKey, skill, gseCenter) и счётчики.
