---
description: Never add kludges or heuristics that guess from text. Use proper data and types.
alwaysApply: true
---

# No kludges (запрет костылей)

**Никогда не делай костыли.** Это не рекомендация — это правило.

## Что считается костылём

- **Угадывание по тексту:** фильтры по словам ("can", "Can "), по длине строки, по количеству слов, по regex по descriptor'у, чтобы понять "тип" или "категорию". Тип должен приходить из данных (поле типа, enum, тип узла из БД/планировщика), а не выводиться из строки.
- **Два источника правды:** если одни и те же сущности (ноды, слова, цели) нужны в двух местах — один источник (API, планировщик, схема). Не "слова из очереди тут, ноды из планировщика там" с надеждой что совпадёт.
- **Магические строки и константы** для бизнес-логики (например "если начинается с Can — это objective") вместо явного типа/поля из модели.
- **Валидация "а давай проверим ответ и если кривой — подставим своё":** убирать причину (не спрашивать то, что может вернуться криво), а не латать последствия.

## Как делать

- **Типы и домены** — из схемы, из API, из планировщика (node.type, domain, targetNodeTypes). Пробрасывай типы явно, не выводи из текста.
- **Один источник правды на контекст:** для задания — ноды и слова из одного вызова/одного слоя; привязка целей — из того же места.
- Если нужно разделить данные (слова vs objectives) — по **полю типа** (GSE_VOCAB / GSE_GRAMMAR / GSE_LO), а не по виду строки.
- Если LLM не должен путать ID — не передавать ему ID, не просить вернуть ID; привязывать ноды со своей стороны из планировщика.

При сомнении: добавляешь ли ты эвристику по тексту/строке вместо использования уже существующего типа или поля? Если да — это костыль. Не делай.
